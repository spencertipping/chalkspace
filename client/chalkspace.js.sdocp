sdocp('client//chalkspace.js.sdoc', 'Chalkspace client | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nChalkspace is a collaborative 3D drawing environment. 3D is achieved by creating a plane (one exists already by default) and drawing on it. It isn\'t designed to be customizable. Rather, it\'s\ndesigned to provide a minimal set of options required to make editing reasonably easy. This includes things like changing the drawing plane\'s position, flipping it into the other axis, and\nmoving the viewport within a 2D plane. That\'s about it though.\n\nModel.\nThe model just contains lines in 3D space. The user has an "active plane" that contains lines. It\'s designed so that every location on the screen maps to a UV-coordinate on the plane. The\nplane is a user-specific object; it isn\'t shared. The user has two options for transforming the plane. One is to translate it along its normal vector, and the other is to rotate it 90 degrees\nalong the Y (vertical) axis.\n\n  Controls.\n  Shift-drag moves the viewport, the spacebar flips the plane, and the up/down arrows and the mousewheel move the plane along its normal vector. Dragging the mouse causes lines to be drawn.\n\n  $(caterwaul.clone(\'std seq continuation montenegro vector\')(function () {\n    l*[b = $(\'body\'), screen = html[canvas] /se[b.append(_)], rpc = caterwaul.montenegro.rpc /re[{listen: _(\'/listen\'), draw: _(\'/draw\')}]] in\n    screen /se[$(window).resize(_) /cps.e[_[0].width = w.width(), _[0].height = w.height(), where[w = $(window)], _.repaint()],\n\n               _.context         = _[0].getContext(\'2d\'),\n               _.clear()         = _.context /se[_.clearRect(0, 0, 500, 500), _.fillStyle = \'#10181c\', _.globalAlpha = 1.0, _.fillRect(0, 0, screen.width(), screen.height())],\n               _.line(v1, v2, o) = _.context /se[_.strokeStyle = \'#eee\', _.strokeWidth = 2.0 / d, _.globalAlpha = (o || 1.0) / d /re[_ > 1 ? 1 : _ < 0 ? 0 : _], _.beginPath(),\n                                                 project(v1) /se.v[_.moveTo(v.x, v.y)], project(v2) /se.v[_.lineTo(v.x, v.y)], _.stroke(), _.closePath(), where[d = depth(v1, v2)]],\n\n               _.draw_cursor() = _ /se[_.line(cursor, cursor.plus(up, 8), 0.5), _.line(cursor, cursor.plus(up.cross(plane.normal), 8), 0.5)],\n               _.repaint()     = _ /se[_.clear(), seq[lines *!l[_.line(l.v1, l.v2)]], _.draw_cursor()],\n\n  Viewport geometry.\n  The canvas is considered to be at z = 0, which is 300 units away from the viewport. This gives a view angle of about 45 degrees on a small screen, and closer to 60 degrees on a large screen.\n  Reverse-projection is basically the ray-tracing algorithm; we need to find the coordinates of the intersection with the plane. The math is fairly simple. We can dot the viewport-screen ray\n  against the plane normal vector to find the intersection distance. Then we just project the ray by that amount. (This follows because the normal vector is normalized.)\n\n  Distance between the plane and a point is also simple. We just need to project the vector between a point on the plane and the point in question onto the plane\'s normal vector. That new\n  vector\'s length is the distance. (We can omit the normal vector measurement since we know it\'s a unit vector anyway.)\n\n               l*[plane_distance(v)  = v.plus(plane.normal.times(plane.d), -1).dot(plane.normal),\n                  intersection(x, y) = l*[d = plane_distance(viewport), direction = view_at(x, y).plus(viewport, -1), dn = direction.dot(plane.normal)] in\n                                       viewport.plus(direction, plane.d / dn)] in\n\n               _ /se[_.mousemove(_) /cps.e[shift_down ? viewport /se[_.x += e.pageX - down.x, _.y += e.pageY - down.y, down.x = e.pageX, down.y = e.pageY] :\n                                                        draw([{v1: cursor, v2: v}]), when[down],\n                                           cursor = v, _.repaint(), where[v = intersection(e.pageX + viewport.x - _.width() / 2, e.pageY + viewport.y - _.height() / 2)]],\n\n                     _.mousedown(_) /cps.e[down = {x: e.pageX, y: e.pageY}],\n                     _.mouseup(_)   /cps.e[down = false],\n\n                     $(document).keydown(_) /cps.e[shift_down = e.which === 16, e.which === 32 && plane.flip() /se[screen.repaint()]],\n                     $(document).keyup(_)   /cps.e[shift_down = false],\n\n                     where[down = false, shift_down = false]],\n\n               $(window).resize(), listen(),\n               where*[project(v)    = l[z = (v.z - viewport.z) / -viewport.z] in {x: (v.x - viewport.x) / z + _.width() / 2, y: (v.y - viewport.y) / z + _.height() / 2},\n                      depth(v1, v2) = ((v1.z + v2.z) / 2.0 - viewport.z) / -viewport.z,\n                      view_at(x, y) = new caterwaul.vector(x, y, 0),\n                      drawing       = \'test\',\n                      lines         = seq[~[]],\n                      cursor        = new caterwaul.vector(0, 0, 0),\n                      up            = new caterwaul.vector(0, 1, 0),\n\n                      listen()      = rpc.listen(drawing, lines.length, _) /cps.ls[seq[~ls *![lines.push(_)]], _.repaint(), listen()],\n                      draw(ls)      = rpc.draw(drawing, ls),\n\n                      plane         = {normal: new caterwaul.vector(-0.2, 0, 0.4).unit(), d: 300} /se[_.flip() = _.normal = _.normal /re[new caterwaul.vector(_.z, _.y, _.x)]],\n                      viewport      = new caterwaul.vector(0, 0, -300)]]}));\n');